{"version":3,"sources":["src/style-settings.js","src/calc-parse.js","src/css-parse.js","src/common-regex.js","src/unscoped-style-handler.js","src/style-util.js","src/apply-shim.js","src/common-utils.js","src/template-map.js","src/apply-shim-utils.js","entrypoints/apply-shim.js"],"names":["nativeShadow","window","nativeCssVariables_","calcCssVariables","settings","navigator","userAgent","match","CSS","supports","cssBuild","ShadyCSS","undefined","disableRuntime","nativeCss","nativeCssVariables","module$src$style_settings.cssBuild","CALC_REGEXP","visitCssExpressions","expressions","depth","map","exp","kind","CssCalcExpression","children","CssOtherExpression","text","join","parseCalc","input","offset","flushReadBuffer","reading","readBuffer","length","syntax","push","span","pos","readingStartCursor","end","cursor","slice","ignore","next","peekIndex","positions","leftParensCount","nextPeek","innerSpan","constructor","StyleNode","parse","replace","RX$$module$src$css_parse.comments","RX$$module$src$css_parse.port","parseCss","root","n","i","l","OPEN_BRACE","p","previous","CLOSE_BRACE","node","t","substring","trim","ss","_expandUnicodeEscapes","RX$$module$src$css_parse.multipleSpaces","lastIndexOf","s","indexOf","AT_START","MEDIA_START","types$$module$src$css_parse.MEDIA_RULE","RX$$module$src$css_parse.keyframesRule","types$$module$src$css_parse.KEYFRAMES_RULE","split","pop","VAR_START","types$$module$src$css_parse.MIXIN_RULE","types$$module$src$css_parse.STYLE_RULE","r$","r","code","repeat","stringify","preserveProperties","cssText","rules","RX$$module$src$css_parse.customProp","RX$$module$src$css_parse.mixinProp","RX$$module$src$css_parse.mixinApply","RX$$module$src$css_parse.varApply","calcMatch","expression","parseResults","STYLE_RULE","KEYFRAMES_RULE","MEDIA_RULE","MIXIN_RULE","comments","port","customProp","mixinProp","mixinApply","varApply","keyframesRule","multipleSpaces","VAR_ASSIGN","MIXIN_MATCH","MEDIA_MATCH","styleTextSet","Set","toCssText","rulesForStyle","style","textContent","forEachRule","styleRuleCallback","keyframesRuleCallback","onlyActiveRules","skipRules","type","matchMedia","matches","processVariableAndFallback","str","callback","start","level","inner","prefix","suffix","comma","value","fallback","getCssBuild","element","__cssBuild","attrValue","getAttribute","CSS_BUILD_ATTR","buildComment","localName","content","firstChild","Comment","commentParts","parentNode","removeChild","APPLY_NAME_CLEAN","INITIAL_INHERIT","IMPORTANT","MixinMap","_map","set","name","props","properties","dependants","get","invalidCallback","ApplyShim","_measureElement","_currentElement","detectMixin","has","test","lastIndex","transformTemplate","template","elementName","_gatheredStyle","styleTextParts","styles","querySelectorAll","hasAttribute","scopingAttribute","add","newStyle","cloneNode","document","head","appendChild","gatherStyles","createElement","insertBefore","transformStyle","ast","transformRules","transformCustomStyle","rule","transformRule","transformCssText","matchText","propertyName","valueProperty","valueMixin","_produceCssProperties","_consumeCssProperties","_fallbacksFromPreviousRules","startRule","topRule","fallbacks","seenStartRule","Object","assign","_cssTextToMap","m","exec","mixinName","idx","index","textBeforeApply","textAfterApply","defaults","_atApplyToCssProperties","vars","mixinEntry","f","parts","MIXIN_VAR_SEP","replacement","replaceInitialOrInherit","property","out","sp","_replaceInitialOrInherit","_getInitialValueForProperty","setAttribute","all","getComputedStyle","getPropertyValue","_invalidateMixinEntry","mixinAsProperties","combinedProps","mixinValues","oldProps","create","needToInvalidate","v","prototype","defineProperty","cb","templateMap","promise","Promise","resolve","invalidate","templateIsValid","startValidatingTemplate","_validating","then","applyShim","ApplyShimInterface","customStyleInterface","ensure","CustomStyleInterface","requestAnimationFrame","flushCustomStyles","prepareTemplate","styleSubtree","removeProperty","setProperty","shadowRoot","styleElement","shadowChildren","childNodes","is","querySelector","styleDocument","body","ScopingShim","applyShimInterface","prepareTemplateStyles","elementExtends","prepareTemplateDom","getComputedStyleValue"],"mappings":"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","file":"apply-shim.min.js","sourcesContent":["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n'use strict';\n\nexport const nativeShadow = !(window['ShadyDOM'] && window['ShadyDOM']['inUse']);\nlet nativeCssVariables_;\n\n/**\n * @param {(ShadyCSSOptions | ShadyCSSInterface)=} settings\n */\nfunction calcCssVariables(settings) {\n  if (settings && settings['shimcssproperties']) {\n    nativeCssVariables_ = false;\n  } else {\n    // chrome 49 has semi-working css vars, check if box-shadow works\n    // safari 9.1 has a recalc bug: https://bugs.webkit.org/show_bug.cgi?id=155782\n    // However, shim css custom properties are only supported with ShadyDOM enabled,\n    // so fall back on native if we do not detect ShadyDOM\n    // Edge 15: custom properties used in ::before and ::after will also be used in the parent element\n    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12414257/\n    nativeCssVariables_ = nativeShadow || Boolean(!navigator.userAgent.match(/AppleWebKit\\/601|Edge\\/15/) &&\n      window.CSS && CSS.supports && CSS.supports('box-shadow', '0 0 0 var(--foo)'));\n  }\n}\n\n/** @type {string | undefined} */\nexport let cssBuild;\nif (window.ShadyCSS && window.ShadyCSS.cssBuild !== undefined) {\n  cssBuild = window.ShadyCSS.cssBuild;\n}\n\n/** @type {boolean} */\nexport const disableRuntime = Boolean(window.ShadyCSS && window.ShadyCSS.disableRuntime);\n\nif (window.ShadyCSS && window.ShadyCSS.nativeCss !== undefined) {\n  nativeCssVariables_ = window.ShadyCSS.nativeCss;\n} else if (window.ShadyCSS) {\n  calcCssVariables(window.ShadyCSS);\n  // reset window variable to let ShadyCSS API take its place\n  window.ShadyCSS = undefined;\n} else {\n  calcCssVariables(window['WebComponents'] && window['WebComponents']['flags']);\n}\n\n// Hack for type error under new type inference which doesn't like that\n// nativeCssVariables is updated in a function and assigns the type\n// `function(): ?` instead of `boolean`.\nexport const nativeCssVariables = /** @type {boolean} */(nativeCssVariables_);","/**\n @license\n Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n Code distributed by Google as part of the polymer project is also\n subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n'use strict';\n\n/** @enum {string} */\nconst CssExpressionKind = {\n\tCssCalcExpression: 'CssCalcExpression',\n\tCssOtherExpression: 'CssOtherExpression'\n};\n\n/** @typedef {{pos: number, end: number}} */\nlet TextSpan; // eslint-disable-line no-unused-vars\n\n/** @typedef {{kind: CssExpressionKind, text: string, span: Text}} */\nlet CssOtherExpression; // eslint-disable-line no-unused-vars\n\n/** @typedef {{kind: CssExpressionKind, text: string, span: Text, children: Array<CssExpression>}} */\nlet CssCalcExpression; // eslint-disable-line no-unused-vars\n\n/** @typedef {CssOtherExpression|CssCalcExpression} */\nlet CssExpression; // eslint-disable-line no-unused-vars\n\n/**\n * A Regular Expression that matches the string 'calc('\n * @const\n * @type {RegExp}\n */\nconst CALC_REGEXP = /calc\\(/g;\n\n/**\n * Visits and stringifies the given CssCalcExpression\n * @param {CssCalcExpression} expression\n * @param {number} depth\n * @returns {string}\n */\nfunction visitCssCalcExpression (expression, depth) {\n\treturn depth === 0\n\t\t? `calc(${visitCssExpressions(expression.children, depth + 1)})`\n\t\t: `(${visitCssExpressions(expression.children, depth + 1)})`;\n}\n\n/**\n * Visits and stringifies the given CSSOtherExpression\n * @param {CssOtherExpression} expression\n * @returns {string}\n */\nfunction visitCssOtherExpression (expression) {\n\treturn expression.text;\n}\n\n/**\n * Visits and stringifies the given CSSExpression\n * @param {CssExpression} expression\n * @param {number} depth\n * @returns {string}\n */\nfunction visitCssExpression (expression, depth) {\n\tswitch (expression.kind) {\n\t\tcase CssExpressionKind.CssCalcExpression:\n\t\t\treturn visitCssCalcExpression( /** @type {CssCalcExpression} */ (expression), depth);\n\t\tcase CssExpressionKind.CssOtherExpression:\n\t\t\treturn visitCssOtherExpression(/** @type {CssOtherExpression} */ (expression));\n\t\tdefault:\n\t\t\treturn '';\n\t}\n}\n\n/**\n * Visits the given CSSExpressions and stringifies them\n * @param {Array<CssExpression>} expressions\n * @param {number} [depth=0]\n * @returns {string}\n */\nfunction visitCssExpressions (expressions, depth = 0) {\n\treturn expressions.map(exp => visitCssExpression(exp, /** @type {number} */ (depth))).join('');\n}\n\n/**\n * A minimal parser that checks CSS declaration values for 'calc' expressions and generates a syntax tree\n * @param {string} input\n * @param {TextSpan} offset\n * @returns {Array<CssExpression>}\n */\nfunction parseCalc (input, offset = {pos: 0, end: input.length}) {\n\tlet cursor = offset.pos + -1;\n\tconst syntax = [];\n\n\tconst isEOF = () => cursor >= input.length || cursor >= offset.end;\n\tconst nextToken = () => input[++cursor];\n\tconst peek = positions => input[cursor + positions];\n\n\t/** @type {Array<string>} */\n\tlet readBuffer = [];\n\tlet readingStartCursor = cursor;\n\tlet reading = false;\n\tlet ignore = false;\n\n\tconst startReading = () => {\n\t\treadingStartCursor = cursor;\n\t\treading = true;\n\t};\n\n\tconst flushReadBuffer = () => {\n\t\treading = false;\n\t\tif (readBuffer.length > 0) {\n\t\t\tsyntax.push({\n\t\t\t\tkind: CssExpressionKind.CssOtherExpression,\n\t\t\t\tspan: {\n\t\t\t\t\tpos: readingStartCursor,\n\t\t\t\t\tend: cursor\n\t\t\t\t},\n\t\t\t\ttext: input.slice(readingStartCursor, cursor)\n\t\t\t});\n\t\t}\n\t\treadBuffer = [];\n\t\treadingStartCursor = cursor;\n\t};\n\n\twhile (!isEOF()) {\n\t\tconst next = nextToken();\n\n\t\tlet peekIndex = 0;\n\n\t\t// Check if the next token leads to a 'calc' expression\n\t\tif (\n\t\t\t!ignore &&\n\t\t\tnext === 'c' &&\n\t\t\tpeek(++peekIndex) === 'a' &&\n\t\t\tpeek(++peekIndex) === 'l' &&\n\t\t\tpeek(++peekIndex) === 'c' &&\n\t\t\tpeek(++peekIndex) === '('\n\t\t) {\n\t\t\tflushReadBuffer();\n\n\t\t\tlet leftParensCount = 0;\n\t\t\twhile (peekIndex < input.length) {\n\t\t\t\tconst nextPeek = peek(peekIndex++);\n\t\t\t\tif (nextPeek === '(') {\n\t\t\t\t\tleftParensCount++;\n\t\t\t\t} else if (nextPeek === ')') {\n\t\t\t\t\tleftParensCount--;\n\n\t\t\t\t\tif (leftParensCount === 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst span = {\n\t\t\t\tpos: cursor,\n\t\t\t\tend: cursor + peekIndex\n\t\t\t};\n\n\t\t\tconst innerSpan = {\n\t\t\t\tpos: span.pos + 'calc('.length,\n\t\t\t\tend: span.end - 1\n\t\t\t};\n\n\t\t\tsyntax.push({\n\t\t\t\tkind: CssExpressionKind.CssCalcExpression,\n\t\t\t\tspan,\n\t\t\t\ttext: input.slice(span.pos, span.end),\n\t\t\t\tchildren: parseCalc(input, innerSpan)\n\t\t\t});\n\n\t\t\tcursor = span.end;\n\t\t\treadingStartCursor = span.end;\n\t\t\treading = true;\n\t\t} else {\n\t\t\t// The next char may be the beginning of a comment\n\t\t\tif (\n\t\t\t\tnext === '/' &&\n\t\t\t\tpeek(1) === '*'\n\t\t\t) {\n\t\t\t\tignore = true;\n\t\t\t}\n\n\t\t\t// The next char may be the beginning of the end of a comment\n\t\t\telse if (\n\t\t\t\tnext === '*' &&\n\t\t\t\tpeek(1) === '/'\n\t\t\t) {\n\t\t\t\tignore = false;\n\t\t\t}\n\n\t\t\t// Read the input and add to the read buffer\n\t\t\tif (!reading) {\n\t\t\t\tstartReading();\n\t\t\t}\n\n\t\t\tif (next != null) {\n\t\t\t\treadBuffer.push(next);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Stop reading\n\tflushReadBuffer();\n\treturn syntax;\n}\n\n/**\n * Reduces 'calc(...)'s inside the given expression which can cssText, a CSS declaration, or a ruleset\n * @param {string} expression\n * @return {string}\n */\nexport function reduceCalc (expression) {\n\t// This heuristic takes a fast path if possible\n\tconst calcMatch = expression.match(CALC_REGEXP);\n\n\t// If the expression doesn't include 'calc' or if it only includes one, there's nothing to reduce here.\n\tif (calcMatch == null || calcMatch.length < 2) {\n\t\treturn expression;\n\t}\n\n\t// Otherwise, parse the expression into a syntax tree before reducing it\n\tconst parseResults = parseCalc(expression);\n\treturn visitCssExpressions(parseResults);\n}","/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/*\nExtremely simple css parser. Intended to be not more than what we need\nand definitely not necessarily correct =).\n*/\n\n'use strict';\n\nimport {reduceCalc} from './calc-parse.js';\n\n/** @unrestricted */\nclass StyleNode {\n  constructor() {\n    /** @type {number} */\n    this['start'] = 0;\n    /** @type {number} */\n    this['end'] = 0;\n    /** @type {StyleNode} */\n    this['previous'] = null;\n    /** @type {StyleNode} */\n    this['parent'] = null;\n    /** @type {Array<StyleNode>} */\n    this['rules'] = null;\n    /** @type {string} */\n    this['parsedCssText'] = '';\n    /** @type {string} */\n    this['cssText'] = '';\n    /** @type {boolean} */\n    this['atRule'] = false;\n    /** @type {number} */\n    this['type'] = 0;\n    /** @type {string} */\n    this['keyframesName'] = '';\n    /** @type {string} */\n    this['selector'] = '';\n    /** @type {string} */\n    this['parsedSelector'] = '';\n  }\n}\n\nexport {StyleNode}\n\n// given a string of css, return a simple rule tree\n/**\n * @param {string} text\n * @return {StyleNode}\n */\nexport function parse(text) {\n  text = clean(text);\n  return parseCss(lex(text), text);\n}\n\n// remove stuff we don't care about that may hinder parsing\n/**\n * @param {string} cssText\n * @return {string}\n */\nfunction clean(cssText) {\n  return cssText.replace(RX.comments, '').replace(RX.port, '');\n}\n\n// super simple {...} lexer that returns a node tree\n/**\n * @param {string} text\n * @return {StyleNode}\n */\nfunction lex(text) {\n  let root = new StyleNode();\n  root['start'] = 0;\n  root['end'] = text.length\n  let n = root;\n  for (let i = 0, l = text.length; i < l; i++) {\n    if (text[i] === OPEN_BRACE) {\n      if (!n['rules']) {\n        n['rules'] = [];\n      }\n      let p = n;\n      let previous = p['rules'][p['rules'].length - 1] || null;\n      n = new StyleNode();\n      n['start'] = i + 1;\n      n['parent'] = p;\n      n['previous'] = previous;\n      p['rules'].push(n);\n    } else if (text[i] === CLOSE_BRACE) {\n      n['end'] = i + 1;\n      n = n['parent'] || root;\n    }\n  }\n  return root;\n}\n\n// add selectors/cssText to node tree\n/**\n * @param {StyleNode} node\n * @param {string} text\n * @return {StyleNode}\n */\nfunction parseCss(node, text) {\n  let t = text.substring(node['start'], node['end'] - 1);\n  node['parsedCssText'] = node['cssText'] = t.trim();\n  if (node['parent']) {\n    let ss = node['previous'] ? node['previous']['end'] : node['parent']['start'];\n    t = text.substring(ss, node['start'] - 1);\n    t = _expandUnicodeEscapes(t);\n    t = t.replace(RX.multipleSpaces, ' ');\n    // TODO(sorvell): ad hoc; make selector include only after last ;\n    // helps with mixin syntax\n    t = t.substring(t.lastIndexOf(';') + 1);\n    let s = node['parsedSelector'] = node['selector'] = t.trim();\n    node['atRule'] = (s.indexOf(AT_START) === 0);\n    // note, support a subset of rule types...\n    if (node['atRule']) {\n      if (s.indexOf(MEDIA_START) === 0) {\n        node['type'] = types.MEDIA_RULE;\n      } else if (s.match(RX.keyframesRule)) {\n        node['type'] = types.KEYFRAMES_RULE;\n        node['keyframesName'] =\n          node['selector'].split(RX.multipleSpaces).pop();\n      }\n    } else {\n      if (s.indexOf(VAR_START) === 0) {\n        node['type'] = types.MIXIN_RULE;\n      } else {\n        node['type'] = types.STYLE_RULE;\n      }\n    }\n  }\n  let r$ = node['rules'];\n  if (r$) {\n    for (let i = 0, l = r$.length, r;\n      (i < l) && (r = r$[i]); i++) {\n      parseCss(r, text);\n    }\n  }\n  return node;\n}\n\n/**\n * conversion of sort unicode escapes with spaces like `\\33 ` (and longer) into\n * expanded form that doesn't require trailing space `\\000033`\n * @param {string} s\n * @return {string}\n */\nfunction _expandUnicodeEscapes(s) {\n  return s.replace(/\\\\([0-9a-f]{1,6})\\s/gi, function() {\n    let code = arguments[1],\n      repeat = 6 - code.length;\n    while (repeat--) {\n      code = '0' + code;\n    }\n    return '\\\\' + code;\n  });\n}\n\n/**\n * stringify parsed css.\n * @param {StyleNode} node\n * @param {boolean=} preserveProperties\n * @param {string=} text\n * @return {string}\n */\nexport function stringify(node, preserveProperties, text = '') {\n  // calc rule cssText\n  let cssText = '';\n  if (node['cssText'] || node['rules']) {\n    let r$ = node['rules'];\n    if (r$ && !_hasMixinRules(r$)) {\n      for (let i = 0, l = r$.length, r;\n        (i < l) && (r = r$[i]); i++) {\n        cssText = stringify(r, preserveProperties, cssText);\n      }\n    } else {\n      cssText = preserveProperties ? node['cssText'] :\n        reduceCalc(removeCustomProps(node['cssText']));\n      cssText = cssText.trim();\n      if (cssText) {\n        cssText = '  ' + cssText + '\\n';\n      }\n    }\n  }\n  // emit rule if there is cssText\n  if (cssText) {\n    if (node['selector']) {\n      text += node['selector'] + ' ' + OPEN_BRACE + '\\n';\n    }\n    text += cssText;\n    if (node['selector']) {\n      text += CLOSE_BRACE + '\\n\\n';\n    }\n  }\n  return text;\n}\n\n/**\n * @param {Array<StyleNode>} rules\n * @return {boolean}\n */\nfunction _hasMixinRules(rules) {\n  let r = rules[0];\n  return Boolean(r) && Boolean(r['selector']) && r['selector'].indexOf(VAR_START) === 0;\n}\n\n/**\n * @param {string} cssText\n * @return {string}\n */\nfunction removeCustomProps(cssText) {\n  cssText = removeCustomPropAssignment(cssText);\n  return removeCustomPropApply(cssText);\n}\n\n/**\n * @param {string} cssText\n * @return {string}\n */\nexport function removeCustomPropAssignment(cssText) {\n  return cssText\n    .replace(RX.customProp, '')\n    .replace(RX.mixinProp, '');\n}\n\n/**\n * @param {string} cssText\n * @return {string}\n */\nfunction removeCustomPropApply(cssText) {\n  return cssText\n    .replace(RX.mixinApply, '')\n    .replace(RX.varApply, '');\n}\n\n/** @enum {number} */\nexport const types = {\n  STYLE_RULE: 1,\n  KEYFRAMES_RULE: 7,\n  MEDIA_RULE: 4,\n  MIXIN_RULE: 1000\n}\n\nconst OPEN_BRACE = '{';\nconst CLOSE_BRACE = '}';\n\n// helper regexp's\nconst RX = {\n  comments: /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//gim,\n  port: /@import[^;]*;/gim,\n  customProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\\n]|$)/gim,\n  mixinProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\\n]|$)?/gim,\n  mixinApply: /@apply\\s*\\(?[^);]*\\)?\\s*(?:[;\\n]|$)?/gim,\n  varApply: /[^;:]*?:[^;]*?var\\([^;]*\\)(?:[;\\n]|$)?/gim,\n  keyframesRule: /^@[^\\s]*keyframes/,\n  multipleSpaces: /\\s+/g\n}\n\nconst VAR_START = '--';\nconst MEDIA_START = '@media';\nconst AT_START = '@';\n","/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nexport const VAR_ASSIGN = /(?:^|[;\\s{]\\s*)(--[\\w-]*?)\\s*:\\s*(?:((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^)]*?\\)|[^};{])+)|\\{([^}]*)\\}(?:(?=[;\\s}])|$))/gi;\nexport const MIXIN_MATCH = /(?:^|\\W+)@apply\\s*\\(?([^);\\n]*)\\)?/gi;\nexport const VAR_CONSUMED = /(--[\\w-]+)\\s*([:,;)]|$)/gi;\nexport const ANIMATION_MATCH = /(animation\\s*:)|(animation-name\\s*:)/;\nexport const MEDIA_MATCH = /@media\\s(.*)/;\nexport const IS_VAR = /^--/;\nexport const BRACKETED = /\\{[^}]*\\}/g;\nexport const HOST_PREFIX = '(?:^|[^.#[:])';\nexport const HOST_SUFFIX = '($|[.:[\\\\s>+~])';\n","/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n'use strict';\n\n/** @type {!Set<string>} */\nconst styleTextSet = new Set();\n\nexport const scopingAttribute = 'shady-unscoped';\n\n/**\n * Add a specifically-marked style to the document directly, and only one copy of that style.\n *\n * @param {!HTMLStyleElement} style\n * @return {undefined}\n */\nexport function processUnscopedStyle(style) {\n  const text = style.textContent;\n  if (!styleTextSet.has(text)) {\n    styleTextSet.add(text);\n    const newStyle = style.cloneNode(true);\n    document.head.appendChild(newStyle);\n  }\n}\n\n/**\n * Check if a style is supposed to be unscoped\n * @param {!HTMLStyleElement} style\n * @return {boolean} true if the style has the unscoping attribute\n */\nexport function isUnscopedStyle(style) {\n  return style.hasAttribute(scopingAttribute);\n}","/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n'use strict';\n\nimport {nativeShadow, nativeCssVariables, cssBuild} from './style-settings.js';\nimport {parse, stringify, types, StyleNode} from './css-parse.js'; // eslint-disable-line no-unused-vars\nimport {MEDIA_MATCH} from './common-regex.js';\nimport {processUnscopedStyle, isUnscopedStyle} from './unscoped-style-handler.js';\n\n/**\n * @param {string|StyleNode} rules\n * @param {function(StyleNode)=} callback\n * @return {string}\n */\nexport function toCssText (rules, callback) {\n  if (!rules) {\n    return '';\n  }\n  if (typeof rules === 'string') {\n    rules = parse(rules);\n  }\n  if (callback) {\n    forEachRule(rules, callback);\n  }\n  return stringify(rules, nativeCssVariables);\n}\n\n/**\n * @param {HTMLStyleElement} style\n * @return {StyleNode}\n */\nexport function rulesForStyle(style) {\n  if (!style['__cssRules'] && style.textContent) {\n    style['__cssRules'] = parse(style.textContent);\n  }\n  return style['__cssRules'] || null;\n}\n\n// Tests if a rule is a keyframes selector, which looks almost exactly\n// like a normal selector but is not (it has nothing to do with scoping\n// for example).\n/**\n * @param {StyleNode} rule\n * @return {boolean}\n */\nexport function isKeyframesSelector(rule) {\n  return Boolean(rule['parent']) &&\n  rule['parent']['type'] === types.KEYFRAMES_RULE;\n}\n\n/**\n * @param {StyleNode} node\n * @param {Function=} styleRuleCallback\n * @param {Function=} keyframesRuleCallback\n * @param {boolean=} onlyActiveRules\n */\nexport function forEachRule(node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {\n  if (!node) {\n    return;\n  }\n  let skipRules = false;\n  let type = node['type'];\n  if (onlyActiveRules) {\n    if (type === types.MEDIA_RULE) {\n      let matchMedia = node['selector'].match(MEDIA_MATCH);\n      if (matchMedia) {\n        // if rule is a non matching @media rule, skip subrules\n        if (!window.matchMedia(matchMedia[1]).matches) {\n          skipRules = true;\n        }\n      }\n    }\n  }\n  if (type === types.STYLE_RULE) {\n    styleRuleCallback(node);\n  } else if (keyframesRuleCallback &&\n    type === types.KEYFRAMES_RULE) {\n    keyframesRuleCallback(node);\n  } else if (type === types.MIXIN_RULE) {\n    skipRules = true;\n  }\n  let r$ = node['rules'];\n  if (r$ && !skipRules) {\n    for (let i=0, l=r$.length, r; (i<l) && (r=r$[i]); i++) {\n      forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);\n    }\n  }\n}\n\n// add a string of cssText to the document.\n/**\n * @param {string} cssText\n * @param {string} moniker\n * @param {Node} target\n * @param {Node} contextNode\n * @return {HTMLStyleElement}\n */\nexport function applyCss(cssText, moniker, target, contextNode) {\n  let style = createScopeStyle(cssText, moniker);\n  applyStyle(style, target, contextNode);\n  return style;\n}\n\n/**\n * @param {string} cssText\n * @param {string} moniker\n * @return {HTMLStyleElement}\n */\nexport function createScopeStyle(cssText, moniker) {\n  let style = /** @type {HTMLStyleElement} */(document.createElement('style'));\n  if (moniker) {\n    style.setAttribute('scope', moniker);\n  }\n  style.textContent = cssText;\n  return style;\n}\n\n/**\n * Track the position of the last added style for placing placeholders\n * @type {Node}\n */\nlet lastHeadApplyNode = null;\n\n// insert a comment node as a styling position placeholder.\n/**\n * @param {string} moniker\n * @return {!Comment}\n */\nexport function applyStylePlaceHolder(moniker) {\n  let placeHolder = document.createComment(' Shady DOM styles for ' +\n    moniker + ' ');\n  let after = lastHeadApplyNode ?\n    lastHeadApplyNode['nextSibling'] : null;\n  let scope = document.head;\n  scope.insertBefore(placeHolder, after || scope.firstChild);\n  lastHeadApplyNode = placeHolder;\n  return placeHolder;\n}\n\n/**\n * @param {HTMLStyleElement} style\n * @param {?Node} target\n * @param {?Node} contextNode\n */\nexport function applyStyle(style, target, contextNode) {\n  target = target || document.head;\n  let after = (contextNode && contextNode.nextSibling) ||\n    target.firstChild;\n  target.insertBefore(style, after);\n  if (!lastHeadApplyNode) {\n    lastHeadApplyNode = style;\n  } else {\n    // only update lastHeadApplyNode if the new style is inserted after the old lastHeadApplyNode\n    let position = style.compareDocumentPosition(lastHeadApplyNode);\n    if (position === Node.DOCUMENT_POSITION_PRECEDING) {\n      lastHeadApplyNode = style;\n    }\n  }\n}\n\n/**\n * @param {string} buildType\n * @return {boolean}\n */\nexport function isTargetedBuild(buildType) {\n  return nativeShadow ? buildType === 'shadow' : buildType === 'shady';\n}\n\n/**\n * Walk from text[start] matching parens and\n * returns position of the outer end paren\n * @param {string} text\n * @param {number} start\n * @return {number}\n */\nexport function findMatchingParen(text, start) {\n  let level = 0;\n  for (let i=start, l=text.length; i < l; i++) {\n    if (text[i] === '(') {\n      level++;\n    } else if (text[i] === ')') {\n      if (--level === 0) {\n        return i;\n      }\n    }\n  }\n  return -1;\n}\n\n/**\n * @param {string} str\n * @param {function(string, string, string, string)} callback\n */\nexport function processVariableAndFallback(str, callback) {\n  // find 'var('\n  let start = str.indexOf('var(');\n  if (start === -1) {\n    // no var?, everything is prefix\n    return callback(str, '', '', '');\n  }\n  //${prefix}var(${inner})${suffix}\n  let end = findMatchingParen(str, start + 3);\n  let inner = str.substring(start + 4, end);\n  let prefix = str.substring(0, start);\n  // suffix may have other variables\n  let suffix = processVariableAndFallback(str.substring(end + 1), callback);\n  let comma = inner.indexOf(',');\n  // value and fallback args should be trimmed to match in property lookup\n  if (comma === -1) {\n    // variable, no fallback\n    return callback(prefix, inner.trim(), '', suffix);\n  }\n  // var(${value},${fallback})\n  let value = inner.substring(0, comma).trim();\n  let fallback = inner.substring(comma + 1).trim();\n  return callback(prefix, value, fallback, suffix);\n}\n\n/**\n * @param {Element} element\n * @param {string} value\n */\nexport function setElementClassRaw(element, value) {\n  // use native setAttribute provided by ShadyDOM when setAttribute is patched\n  if (nativeShadow) {\n    element.setAttribute('class', value);\n  } else {\n    window['ShadyDOM']['nativeMethods']['setAttribute'].call(element, 'class', value);\n  }\n}\n\n/**\n * @type {function(*):*}\n */\nexport const wrap = window['ShadyDOM'] && window['ShadyDOM']['wrap'] || ((node) => node);\n\n/**\n * @param {Element | {is: string, extends: string}} element\n * @return {{is: string, typeExtension: string}}\n */\nexport function getIsExtends(element) {\n  let localName = element['localName'];\n  let is = '', typeExtension = '';\n  /*\n  NOTE: technically, this can be wrong for certain svg elements\n  with `-` in the name like `<font-face>`\n  */\n  if (localName) {\n    if (localName.indexOf('-') > -1) {\n      is = localName;\n    } else {\n      typeExtension = localName;\n      is = (element.getAttribute && element.getAttribute('is')) || '';\n    }\n  } else {\n    is = /** @type {?} */(element).is;\n    typeExtension = /** @type {?} */(element).extends;\n  }\n  return {is, typeExtension};\n}\n\n/**\n * @param {Element|DocumentFragment} element\n * @return {string}\n */\nexport function gatherStyleText(element) {\n  /** @type {!Array<string>} */\n  const styleTextParts = [];\n  const styles = /** @type {!NodeList<!HTMLStyleElement>} */(element.querySelectorAll('style'));\n  for (let i = 0; i < styles.length; i++) {\n    const style = styles[i];\n    if (isUnscopedStyle(style)) {\n      if (!nativeShadow) {\n        processUnscopedStyle(style);\n        style.parentNode.removeChild(style);\n      }\n    } else {\n      styleTextParts.push(style.textContent);\n      style.parentNode.removeChild(style);\n    }\n  }\n  return styleTextParts.join('').trim();\n}\n\n/**\n * Split a selector separated by commas into an array in a smart way\n * @param {string} selector\n * @return {!Array<string>}\n */\nexport function splitSelectorList(selector) {\n  const parts = [];\n  let part = '';\n  for (let i = 0; i >= 0 && i < selector.length; i++) {\n    // A selector with parentheses will be one complete part\n    if (selector[i] === '(') {\n      // find the matching paren\n      const end = findMatchingParen(selector, i);\n      // push the paren block into the part\n      part += selector.slice(i, end + 1);\n      // move the index to after the paren block\n      i = end;\n    } else if (selector[i] === ',') {\n      parts.push(part);\n      part = '';\n    } else {\n      part += selector[i];\n    }\n  }\n  // catch any pieces after the last comma\n  if (part) {\n    parts.push(part);\n  }\n  return parts;\n}\n\nconst CSS_BUILD_ATTR = 'css-build';\n\n/**\n * Return the polymer-css-build \"build type\" applied to this element\n *\n * @param {!HTMLElement} element\n * @return {string} Can be \"\", \"shady\", or \"shadow\"\n */\nexport function getCssBuild(element) {\n  if (cssBuild !== undefined) {\n    return /** @type {string} */(cssBuild);\n  }\n  if (element.__cssBuild === undefined) {\n    // try attribute first, as it is the common case\n    const attrValue = element.getAttribute(CSS_BUILD_ATTR);\n    if (attrValue) {\n      element.__cssBuild = attrValue;\n    } else {\n      const buildComment = getBuildComment(element);\n      if (buildComment !== '') {\n        // remove build comment so it is not needlessly copied into every element instance\n        removeBuildComment(element);\n      }\n      element.__cssBuild = buildComment;\n    }\n  }\n  return element.__cssBuild || '';\n}\n\n/**\n * Check if the given element, either a <template> or <style>, has been processed\n * by polymer-css-build.\n *\n * If so, then we can make a number of optimizations:\n * - polymer-css-build will decompose mixins into individual CSS Custom Properties,\n * so the ApplyShim can be skipped entirely.\n * - Under native ShadowDOM, the style text can just be copied into each instance\n * without modification\n * - If the build is \"shady\" and ShadyDOM is in use, the styling does not need\n * scoping beyond the shimming of CSS Custom Properties\n *\n * @param {!HTMLElement} element\n * @return {boolean}\n */\nexport function elementHasBuiltCss(element) {\n  return getCssBuild(element) !== '';\n}\n\n/**\n * For templates made with tagged template literals, polymer-css-build will\n * insert a comment of the form `<!--css-build:shadow-->`\n *\n * @param {!HTMLElement} element\n * @return {string}\n */\nexport function getBuildComment(element) {\n  const buildComment = element.localName === 'template' ?\n      /** @type {!HTMLTemplateElement} */ (element).content.firstChild :\n      element.firstChild;\n  if (buildComment instanceof Comment) {\n    const commentParts = buildComment.textContent.trim().split(':');\n    if (commentParts[0] === CSS_BUILD_ATTR) {\n      return commentParts[1];\n    }\n  }\n  return '';\n}\n\n/**\n * Check if the css build status is optimal, and do no unneeded work.\n *\n * @param {string=} cssBuild CSS build status\n * @return {boolean} css build is optimal or not\n */\nexport function isOptimalCssBuild(cssBuild = '') {\n  // CSS custom property shim always requires work\n  if (cssBuild === '' || !nativeCssVariables) {\n    return false;\n  }\n  return nativeShadow ? cssBuild === 'shadow' : cssBuild === 'shady';\n}\n\n/**\n * @param {!HTMLElement} element\n */\nfunction removeBuildComment(element) {\n  const buildComment = element.localName === 'template' ?\n      /** @type {!HTMLTemplateElement} */ (element).content.firstChild :\n      element.firstChild;\n  buildComment.parentNode.removeChild(buildComment);\n}\n","/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n/*\n * The apply shim simulates the behavior of `@apply` proposed at\n * https://tabatkins.github.io/specs/css-apply-rule/.\n * The approach is to convert a property like this:\n *\n *    --foo: {color: red; background: blue;}\n *\n * to this:\n *\n *    --foo_-_color: red;\n *    --foo_-_background: blue;\n *\n * Then where `@apply --foo` is used, that is converted to:\n *\n *    color: var(--foo_-_color);\n *    background: var(--foo_-_background);\n *\n * This approach generally works but there are some issues and limitations.\n * Consider, for example, that somewhere *between* where `--foo` is set and used,\n * another element sets it to:\n *\n *    --foo: { border: 2px solid red; }\n *\n * We must now ensure that the color and background from the previous setting\n * do not apply. This is accomplished by changing the property set to this:\n *\n *    --foo_-_border: 2px solid red;\n *    --foo_-_color: initial;\n *    --foo_-_background: initial;\n *\n * This works but introduces one new issue.\n * Consider this setup at the point where the `@apply` is used:\n *\n *    background: orange;\n *    `@apply` --foo;\n *\n * In this case the background will be unset (initial) rather than the desired\n * `orange`. We address this by altering the property set to use a fallback\n * value like this:\n *\n *    color: var(--foo_-_color);\n *    background: var(--foo_-_background, orange);\n *    border: var(--foo_-_border);\n *\n * Note that the default is retained in the property set and the `background` is\n * the desired `orange`. This leads us to a limitation.\n *\n * Limitation 1:\n\n * Only properties in the rule where the `@apply`\n * is used are considered as default values.\n * If another rule matches the element and sets `background` with\n * less specificity than the rule in which `@apply` appears,\n * the `background` will not be set.\n *\n * Limitation 2:\n *\n * When using Polymer's `updateStyles` api, new properties may not be set for\n * `@apply` properties.\n\n*/\n\n'use strict';\n\nimport {forEachRule, processVariableAndFallback, rulesForStyle, toCssText, gatherStyleText} from './style-util.js';\nimport {MIXIN_MATCH, VAR_ASSIGN} from './common-regex.js';\nimport {detectMixin} from './common-utils.js';\nimport {StyleNode} from './css-parse.js'; // eslint-disable-line no-unused-vars\n\nconst APPLY_NAME_CLEAN = /;\\s*/m;\nconst INITIAL_INHERIT = /^\\s*(initial)|(inherit)\\s*$/;\nconst IMPORTANT = /\\s*!important/;\n\n// separator used between mixin-name and mixin-property-name when producing properties\n// NOTE: plain '-' may cause collisions in user styles\nconst MIXIN_VAR_SEP = '_-_';\n\n/**\n * @typedef {!Object<string, string>}\n */\nlet PropertyEntry; // eslint-disable-line no-unused-vars\n\n/**\n * @typedef {!Object<string, boolean>}\n */\nlet DependantsEntry; // eslint-disable-line no-unused-vars\n\n/** @typedef {{\n *    properties: PropertyEntry,\n *    dependants: DependantsEntry\n * }}\n */\nlet MixinMapEntry; // eslint-disable-line no-unused-vars\n\n// map of mixin to property names\n// --foo: {border: 2px} -> {properties: {(--foo, ['border'])}, dependants: {'element-name': proto}}\nclass MixinMap {\n  constructor() {\n    /** @type {!Object<string, !MixinMapEntry>} */\n    this._map = {};\n  }\n  /**\n   * @param {string} name\n   * @param {!PropertyEntry} props\n   */\n  set(name, props) {\n    name = name.trim();\n    this._map[name] = {\n      properties: props,\n      dependants: {}\n    }\n  }\n  /**\n   * @param {string} name\n   * @return {MixinMapEntry}\n   */\n  get(name) {\n    name = name.trim();\n    return this._map[name] || null;\n  }\n}\n\n/**\n * Callback for when an element is marked invalid\n * @type {?function(string)}\n */\nlet invalidCallback = null;\n\n/** @unrestricted */\nclass ApplyShim {\n  constructor() {\n    /** @type {?string} */\n    this._currentElement = null;\n    /** @type {HTMLMetaElement} */\n    this._measureElement = null;\n    this._map = new MixinMap();\n  }\n  /**\n   * return true if `cssText` contains a mixin definition or consumption\n   * @param {string} cssText\n   * @return {boolean}\n   */\n  detectMixin(cssText) {\n    return detectMixin(cssText);\n  }\n\n  /**\n   * Gather styles into one style for easier processing\n   * @param {!HTMLTemplateElement} template\n   * @return {HTMLStyleElement}\n   */\n  gatherStyles(template) {\n    const styleText = gatherStyleText(template.content);\n    if (styleText) {\n      const style = /** @type {!HTMLStyleElement} */(document.createElement('style'));\n      style.textContent = styleText;\n      template.content.insertBefore(style, template.content.firstChild);\n      return style;\n    }\n    return null;\n  }\n  /**\n   * @param {!HTMLTemplateElement} template\n   * @param {string} elementName\n   * @return {StyleNode}\n   */\n  transformTemplate(template, elementName) {\n    if (template._gatheredStyle === undefined) {\n      template._gatheredStyle = this.gatherStyles(template);\n    }\n    /** @type {HTMLStyleElement} */\n    const style = template._gatheredStyle;\n    return style ? this.transformStyle(style, elementName) : null;\n  }\n  /**\n   * @param {!HTMLStyleElement} style\n   * @param {string} elementName\n   * @return {StyleNode}\n   */\n  transformStyle(style, elementName = '') {\n    let ast = rulesForStyle(style);\n    this.transformRules(ast, elementName);\n    style.textContent = toCssText(ast);\n    return ast;\n  }\n  /**\n   * @param {!HTMLStyleElement} style\n   * @return {StyleNode}\n   */\n  transformCustomStyle(style) {\n    let ast = rulesForStyle(style);\n    forEachRule(ast, (rule) => {\n      if (rule['selector'] === ':root') {\n        rule['selector'] = 'html';\n      }\n      this.transformRule(rule);\n    })\n    style.textContent = toCssText(ast);\n    return ast;\n  }\n  /**\n   * @param {StyleNode} rules\n   * @param {string} elementName\n   */\n  transformRules(rules, elementName) {\n    this._currentElement = elementName;\n    forEachRule(rules, (r) => {\n      this.transformRule(r);\n    });\n    this._currentElement = null;\n  }\n  /**\n   * @param {!StyleNode} rule\n   */\n  transformRule(rule) {\n    rule['cssText'] = this.transformCssText(rule['parsedCssText'], rule);\n    // :root was only used for variable assignment in property shim,\n    // but generates invalid selectors with real properties.\n    // replace with `:host > *`, which serves the same effect\n    if (rule['selector'] === ':root') {\n      rule['selector'] = ':host > *';\n    }\n  }\n  /**\n   * @param {string} cssText\n   * @param {!StyleNode} rule\n   * @return {string}\n   */\n  transformCssText(cssText, rule) {\n    // produce variables\n    cssText = cssText.replace(VAR_ASSIGN, (matchText, propertyName, valueProperty, valueMixin) =>\n      this._produceCssProperties(matchText, propertyName, valueProperty, valueMixin, rule));\n    // consume mixins\n    return this._consumeCssProperties(cssText, rule);\n  }\n  /**\n   * @param {string} property\n   * @return {string}\n   */\n  _getInitialValueForProperty(property) {\n    if (!this._measureElement) {\n      this._measureElement = /** @type {HTMLMetaElement} */(document.createElement('meta'));\n      this._measureElement.setAttribute('apply-shim-measure', '');\n      this._measureElement.style.all = 'initial';\n      document.head.appendChild(this._measureElement);\n    }\n    return window.getComputedStyle(this._measureElement).getPropertyValue(property);\n  }\n  /**\n   * Walk over all rules before this rule to find fallbacks for mixins\n   *\n   * @param {!StyleNode} startRule\n   * @return {!Object}\n   */\n  _fallbacksFromPreviousRules(startRule) {\n    // find the \"top\" rule\n    let topRule = startRule;\n    while (topRule['parent']) {\n      topRule = topRule['parent'];\n    }\n    const fallbacks = {};\n    let seenStartRule = false;\n    forEachRule(topRule, (r) => {\n      // stop when we hit the input rule\n      seenStartRule = seenStartRule || r === startRule;\n      if (seenStartRule) {\n        return;\n      }\n      // NOTE: Only matching selectors are \"safe\" for this fallback processing\n      // It would be prohibitive to run `matchesSelector()` on each selector,\n      // so we cheat and only check if the same selector string is used, which\n      // guarantees things like specificity matching\n      if (r['selector'] === startRule['selector']) {\n        Object.assign(fallbacks, this._cssTextToMap(r['parsedCssText']));\n      }\n    });\n    return fallbacks;\n  }\n  /**\n   * replace mixin consumption with variable consumption\n   * @param {string} text\n   * @param {!StyleNode=} rule\n   * @return {string}\n   */\n  _consumeCssProperties(text, rule) {\n    /** @type {Array} */\n    let m = null;\n    // loop over text until all mixins with defintions have been applied\n    while((m = MIXIN_MATCH.exec(text))) {\n      let matchText = m[0];\n      let mixinName = m[1];\n      let idx = m.index;\n      // collect properties before apply to be \"defaults\" if mixin might override them\n      // match includes a \"prefix\", so find the start and end positions of @apply\n      let applyPos = idx + matchText.indexOf('@apply');\n      let afterApplyPos = idx + matchText.length;\n      // find props defined before this @apply\n      let textBeforeApply = text.slice(0, applyPos);\n      let textAfterApply = text.slice(afterApplyPos);\n      let defaults = rule ? this._fallbacksFromPreviousRules(rule) : {};\n      Object.assign(defaults, this._cssTextToMap(textBeforeApply));\n      let replacement = this._atApplyToCssProperties(mixinName, defaults);\n      // use regex match position to replace mixin, keep linear processing time\n      text = `${textBeforeApply}${replacement}${textAfterApply}`;\n      // move regex search to _after_ replacement\n      MIXIN_MATCH.lastIndex = idx + replacement.length;\n    }\n    return text;\n  }\n  /**\n   * produce variable consumption at the site of mixin consumption\n   * `@apply` --foo; -> for all props (${propname}: var(--foo_-_${propname}, ${fallback[propname]}}))\n   * Example:\n   *  border: var(--foo_-_border); padding: var(--foo_-_padding, 2px)\n   *\n   * @param {string} mixinName\n   * @param {Object} fallbacks\n   * @return {string}\n   */\n  _atApplyToCssProperties(mixinName, fallbacks) {\n    mixinName = mixinName.replace(APPLY_NAME_CLEAN, '');\n    let vars = [];\n    let mixinEntry = this._map.get(mixinName);\n    // if we depend on a mixin before it is created\n    // make a sentinel entry in the map to add this element as a dependency for when it is defined.\n    if (!mixinEntry) {\n      this._map.set(mixinName, {});\n      mixinEntry = this._map.get(mixinName);\n    }\n    if (mixinEntry) {\n      if (this._currentElement) {\n        mixinEntry.dependants[this._currentElement] = true;\n      }\n      let p, parts, f;\n      const properties = mixinEntry.properties;\n      for (p in properties) {\n        f = fallbacks && fallbacks[p];\n        parts = [p, ': var(', mixinName, MIXIN_VAR_SEP, p];\n        if (f) {\n          parts.push(',', f.replace(IMPORTANT, ''));\n        }\n        parts.push(')');\n        if (IMPORTANT.test(properties[p])) {\n          parts.push(' !important');\n        }\n        vars.push(parts.join(''));\n      }\n    }\n    return vars.join('; ');\n  }\n\n  /**\n   * @param {string} property\n   * @param {string} value\n   * @return {string}\n   */\n  _replaceInitialOrInherit(property, value) {\n    let match = INITIAL_INHERIT.exec(value);\n    if (match) {\n      if (match[1]) {\n        // initial\n        // replace `initial` with the concrete initial value for this property\n        value = this._getInitialValueForProperty(property);\n      } else {\n        // inherit\n        // with this purposfully illegal value, the variable will be invalid at\n        // compute time (https://www.w3.org/TR/css-variables/#invalid-at-computed-value-time)\n        // and for inheriting values, will behave similarly\n        // we cannot support the same behavior for non inheriting values like 'border'\n        value = 'apply-shim-inherit';\n      }\n    }\n    return value;\n  }\n\n  /**\n   * \"parse\" a mixin definition into a map of properties and values\n   * cssTextToMap('border: 2px solid black') -> ('border', '2px solid black')\n   * @param {string} text\n   * @param {boolean=} replaceInitialOrInherit\n   * @return {!Object<string, string>}\n   */\n  _cssTextToMap(text, replaceInitialOrInherit = false) {\n    let props = text.split(';');\n    let property, value;\n    let out = {};\n    for (let i = 0, p, sp; i < props.length; i++) {\n      p = props[i];\n      if (p) {\n        sp = p.split(':');\n        // ignore lines that aren't definitions like @media\n        if (sp.length > 1) {\n          property = sp[0].trim();\n          // some properties may have ':' in the value, like data urls\n          value = sp.slice(1).join(':');\n          if (replaceInitialOrInherit) {\n            value = this._replaceInitialOrInherit(property, value);\n          }\n          out[property] = value;\n        }\n      }\n    }\n    return out;\n  }\n\n  /**\n   * @param {MixinMapEntry} mixinEntry\n   */\n  _invalidateMixinEntry(mixinEntry) {\n    if (!invalidCallback) {\n      return;\n    }\n    for (let elementName in mixinEntry.dependants) {\n      if (elementName !== this._currentElement) {\n        invalidCallback(elementName);\n      }\n    }\n  }\n\n  /**\n   * @param {string} matchText\n   * @param {string} propertyName\n   * @param {?string} valueProperty\n   * @param {?string} valueMixin\n   * @param {!StyleNode} rule\n   * @return {string}\n   */\n  _produceCssProperties(matchText, propertyName, valueProperty, valueMixin, rule) {\n    // handle case where property value is a mixin\n    if (valueProperty) {\n      // form: --mixin2: var(--mixin1), where --mixin1 is in the map\n      processVariableAndFallback(valueProperty, (prefix, value) => {\n        if (value && this._map.get(value)) {\n          valueMixin = `@apply ${value};`\n        }\n      });\n    }\n    if (!valueMixin) {\n      return matchText;\n    }\n    let mixinAsProperties = this._consumeCssProperties('' + valueMixin, rule);\n    let prefix = matchText.slice(0, matchText.indexOf('--'));\n    // `initial` and `inherit` as properties in a map should be replaced because\n    // these keywords are eagerly evaluated when the mixin becomes CSS Custom Properties,\n    // and would set the variable value, rather than carry the keyword to the `var()` usage.\n    let mixinValues = this._cssTextToMap(mixinAsProperties, true);\n    let combinedProps = mixinValues;\n    let mixinEntry = this._map.get(propertyName);\n    let oldProps = mixinEntry && mixinEntry.properties;\n    if (oldProps) {\n      // NOTE: since we use mixin, the map of properties is updated here\n      // and this is what we want.\n      combinedProps = Object.assign(Object.create(oldProps), mixinValues);\n    } else {\n      this._map.set(propertyName, combinedProps);\n    }\n    let out = [];\n    let p, v;\n    // set variables defined by current mixin\n    let needToInvalidate = false;\n    for (p in combinedProps) {\n      v = mixinValues[p];\n      // if property not defined by current mixin, set initial\n      if (v === undefined) {\n        v = 'initial';\n      }\n      if (oldProps && !(p in oldProps)) {\n        needToInvalidate = true;\n      }\n      out.push(`${propertyName}${MIXIN_VAR_SEP}${p}: ${v}`);\n    }\n    if (needToInvalidate) {\n      this._invalidateMixinEntry(mixinEntry);\n    }\n    if (mixinEntry) {\n      mixinEntry.properties = combinedProps;\n    }\n    // because the mixinMap is global, the mixin might conflict with\n    // a different scope's simple variable definition:\n    // Example:\n    // some style somewhere:\n    // --mixin1:{ ... }\n    // --mixin2: var(--mixin1);\n    // some other element:\n    // --mixin1: 10px solid red;\n    // --foo: var(--mixin1);\n    // In this case, we leave the original variable definition in place.\n    if (valueProperty) {\n      prefix = `${matchText};${prefix}`;\n    }\n    return `${prefix}${out.join('; ')};`;\n  }\n}\n\n/* exports */\n/* eslint-disable no-self-assign */\nApplyShim.prototype['detectMixin'] = ApplyShim.prototype.detectMixin;\nApplyShim.prototype['transformStyle'] = ApplyShim.prototype.transformStyle;\nApplyShim.prototype['transformCustomStyle'] = ApplyShim.prototype.transformCustomStyle;\nApplyShim.prototype['transformRules'] = ApplyShim.prototype.transformRules;\nApplyShim.prototype['transformRule'] = ApplyShim.prototype.transformRule;\nApplyShim.prototype['transformTemplate'] = ApplyShim.prototype.transformTemplate;\nApplyShim.prototype['_separator'] = MIXIN_VAR_SEP;\n/* eslint-enable no-self-assign */\nObject.defineProperty(ApplyShim.prototype, 'invalidCallback', {\n  /** @return {?function(string)} */\n  get() {\n    return invalidCallback;\n  },\n  /** @param {?function(string)} cb */\n  set(cb) {\n    invalidCallback = cb;\n  }\n});\n\nexport default ApplyShim;\n","/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n'use strict';\n\nimport { MIXIN_MATCH, VAR_ASSIGN } from './common-regex.js';\n\n/**\n * @param {Element} element\n * @param {Object=} properties\n */\nexport function updateNativeProperties(element, properties) {\n  // remove previous properties\n  for (let p in properties) {\n    // NOTE: for bc with shim, don't apply null values.\n    if (p === null) {\n      element.style.removeProperty(p);\n    } else {\n      element.style.setProperty(p, properties[p]);\n    }\n  }\n}\n\n/**\n * @param {Element} element\n * @param {string} property\n * @return {string}\n */\nexport function getComputedStyleValue(element, property) {\n  /**\n   * @const {string}\n   */\n  const value = window.getComputedStyle(element).getPropertyValue(property);\n  if (!value) {\n    return '';\n  } else {\n    return value.trim();\n  }\n}\n\n/**\n * return true if `cssText` contains a mixin definition or consumption\n * @param {string} cssText\n * @return {boolean}\n */\nexport function detectMixin(cssText) {\n  const has = MIXIN_MATCH.test(cssText) || VAR_ASSIGN.test(cssText);\n  // reset state of the regexes\n  MIXIN_MATCH.lastIndex = 0;\n  VAR_ASSIGN.lastIndex = 0;\n  return has;\n}\n","/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n'use strict';\n\n/**\n * @const {!Object<string, !HTMLTemplateElement>}\n */\nconst templateMap = {};\nexport default templateMap;\n","/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n'use strict';\nimport templateMap from './template-map.js';\nimport {StyleNode} from './css-parse.js'; // eslint-disable-line no-unused-vars\n\n/*\n * Utilities for handling invalidating apply-shim mixins for a given template.\n *\n * The invalidation strategy involves keeping track of the \"current\" version of a template's mixins, and updating that count when a mixin is invalidated.\n * The template\n */\n\n/** @const {string} */\nconst CURRENT_VERSION = '_applyShimCurrentVersion';\n\n/** @const {string} */\nconst NEXT_VERSION = '_applyShimNextVersion';\n\n/** @const {string} */\nconst VALIDATING_VERSION = '_applyShimValidatingVersion';\n\n/**\n * @const {Promise<void>}\n */\nconst promise = Promise.resolve();\n\n/**\n * @param {string} elementName\n */\nexport function invalidate(elementName){\n  let template = templateMap[elementName];\n  if (template) {\n    invalidateTemplate(template);\n  }\n}\n\n/**\n * This function can be called multiple times to mark a template invalid\n * and signal that the style inside must be regenerated.\n *\n * Use `startValidatingTemplate` to begin an asynchronous validation cycle.\n * During that cycle, call `templateIsValidating` to see if the template must\n * be revalidated\n * @param {HTMLTemplateElement} template\n */\nexport function invalidateTemplate(template) {\n  // default the current version to 0\n  template[CURRENT_VERSION] = template[CURRENT_VERSION] || 0;\n  // ensure the \"validating for\" flag exists\n  template[VALIDATING_VERSION] = template[VALIDATING_VERSION] || 0;\n  // increment the next version\n  template[NEXT_VERSION] = (template[NEXT_VERSION] || 0) + 1;\n}\n\n/**\n * @param {string} elementName\n * @return {boolean}\n */\nexport function isValid(elementName) {\n  let template = templateMap[elementName];\n  if (template) {\n    return templateIsValid(template);\n  }\n  return true;\n}\n\n/**\n * @param {HTMLTemplateElement} template\n * @return {boolean}\n */\nexport function templateIsValid(template) {\n  return template[CURRENT_VERSION] === template[NEXT_VERSION];\n}\n\n/**\n * @param {string} elementName\n * @return {boolean}\n */\nexport function isValidating(elementName) {\n  let template = templateMap[elementName];\n  if (template) {\n    return templateIsValidating(template);\n  }\n  return false;\n}\n\n/**\n * Returns true if the template is currently invalid and `startValidating` has been called since the last invalidation.\n * If false, the template must be validated.\n * @param {HTMLTemplateElement} template\n * @return {boolean}\n */\nexport function templateIsValidating(template) {\n  return !templateIsValid(template) && template[VALIDATING_VERSION] === template[NEXT_VERSION];\n}\n\n/**\n * the template is marked as `validating` for one microtask so that all instances\n * found in the tree crawl of `applyStyle` will update themselves,\n * but the template will only be updated once.\n * @param {string} elementName\n*/\nexport function startValidating(elementName) {\n  let template = templateMap[elementName];\n  startValidatingTemplate(template);\n}\n\n/**\n * Begin an asynchronous invalidation cycle.\n * This should be called after every validation of a template\n *\n * After one microtask, the template will be marked as valid until the next call to `invalidateTemplate`\n * @param {HTMLTemplateElement} template\n */\nexport function startValidatingTemplate(template) {\n  // remember that the current \"next version\" is the reason for this validation cycle\n  template[VALIDATING_VERSION] = template[NEXT_VERSION];\n  // however, there only needs to be one async task to clear the counters\n  if (!template._validating) {\n    template._validating = true;\n    promise.then(function() {\n      // sync the current version to let future invalidations cause a refresh cycle\n      template[CURRENT_VERSION] = template[NEXT_VERSION];\n      template._validating = false;\n    });\n  }\n}\n\n/**\n * @return {boolean}\n */\nexport function elementsAreInvalid() {\n  for (let elementName in templateMap) {\n    let template = templateMap[elementName];\n    if (!templateIsValid(template)) {\n      return true;\n    }\n  }\n  return false;\n}\n","/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n'use strict';\n\nimport ApplyShim from '../src/apply-shim.js';\nimport templateMap from '../src/template-map.js';\nimport {getIsExtends, toCssText, elementHasBuiltCss} from '../src/style-util.js';\nimport * as ApplyShimUtils from '../src/apply-shim-utils.js';\nimport {getComputedStyleValue, updateNativeProperties} from '../src/common-utils.js';\nimport {CustomStyleInterfaceInterface} from '../src/custom-style-interface.js'; // eslint-disable-line no-unused-vars\nimport {nativeCssVariables, nativeShadow, cssBuild, disableRuntime} from '../src/style-settings.js';\n\n/** @const {ApplyShim} */\nconst applyShim = new ApplyShim();\n\nclass ApplyShimInterface {\n  constructor() {\n    /** @type {?CustomStyleInterfaceInterface} */\n    this.customStyleInterface = null;\n    applyShim['invalidCallback'] = ApplyShimUtils.invalidate;\n  }\n  ensure() {\n    if (this.customStyleInterface) {\n      return;\n    }\n    if (window.ShadyCSS.CustomStyleInterface) {\n      this.customStyleInterface =\n          /** @type {!CustomStyleInterfaceInterface} */ (\n              window.ShadyCSS.CustomStyleInterface);\n      this.customStyleInterface['transformCallback'] = (style) => {\n        applyShim.transformCustomStyle(style);\n      };\n      this.customStyleInterface['validateCallback'] = () => {\n        requestAnimationFrame(() => {\n          if (this.customStyleInterface['enqueued']) {\n            this.flushCustomStyles();\n          }\n        });\n      }\n    }\n  }\n  /**\n   * @param {!HTMLTemplateElement} template\n   * @param {string} elementName\n   */\n  prepareTemplate(template, elementName) {\n    this.ensure();\n    if (elementHasBuiltCss(template)) {\n      return;\n    }\n    templateMap[elementName] = template;\n    let ast = applyShim.transformTemplate(template, elementName);\n    // save original style ast to use for revalidating instances\n    template['_styleAst'] = ast;\n  }\n  flushCustomStyles() {\n    this.ensure();\n    if (!this.customStyleInterface) {\n      return;\n    }\n    let styles = this.customStyleInterface['processStyles']();\n    if (!this.customStyleInterface['enqueued']) {\n      return;\n    }\n    for (let i = 0; i < styles.length; i++ ) {\n      let cs = styles[i];\n      let style = this.customStyleInterface['getStyleForCustomStyle'](cs);\n      if (style) {\n        applyShim.transformCustomStyle(style);\n      }\n    }\n    this.customStyleInterface['enqueued'] = false;\n  }\n  /**\n   * @param {HTMLElement} element\n   * @param {Object=} properties\n   */\n  styleSubtree(element, properties) {\n    this.ensure();\n    if (properties) {\n      updateNativeProperties(element, properties);\n    }\n    if (element.shadowRoot) {\n      this.styleElement(element);\n      let shadowChildren =\n          /** @type {!ParentNode} */ (element.shadowRoot).children ||\n          element.shadowRoot.childNodes;\n      for (let i = 0; i < shadowChildren.length; i++) {\n        this.styleSubtree(/** @type {HTMLElement} */(shadowChildren[i]));\n      }\n    } else {\n      let children = element.children || element.childNodes;\n      for (let i = 0; i < children.length; i++) {\n        this.styleSubtree(/** @type {HTMLElement} */(children[i]));\n      }\n    }\n  }\n  /**\n   * @param {HTMLElement} element\n   */\n  styleElement(element) {\n    this.ensure();\n    let {is} = getIsExtends(element);\n    let template = templateMap[is];\n    if (template && elementHasBuiltCss(template)) {\n      return;\n    }\n    if (template && !ApplyShimUtils.templateIsValid(template)) {\n      // only revalidate template once\n      if (!ApplyShimUtils.templateIsValidating(template)) {\n        this.prepareTemplate(template, is);\n        ApplyShimUtils.startValidatingTemplate(template);\n      }\n      // update this element instance\n      let root = element.shadowRoot;\n      if (root) {\n        let style = /** @type {HTMLStyleElement} */(root.querySelector('style'));\n        if (style) {\n          // reuse the template's style ast, it has all the original css text\n          style['__cssRules'] = template['_styleAst'];\n          style.textContent = toCssText(template['_styleAst'])\n        }\n      }\n    }\n  }\n  /**\n   * @param {Object=} properties\n   */\n  styleDocument(properties) {\n    this.ensure();\n    this.styleSubtree(document.body, properties);\n  }\n}\n\nif (!window.ShadyCSS || !window.ShadyCSS.ScopingShim) {\n  const applyShimInterface = new ApplyShimInterface();\n  let CustomStyleInterface = window.ShadyCSS && window.ShadyCSS.CustomStyleInterface;\n\n  /** @suppress {duplicate} */\n  window.ShadyCSS = {\n    /**\n     * @param {!HTMLTemplateElement} template\n     * @param {string} elementName\n     * @param {string=} elementExtends\n     */\n    prepareTemplate(template, elementName, elementExtends) { // eslint-disable-line no-unused-vars\n      applyShimInterface.flushCustomStyles();\n      applyShimInterface.prepareTemplate(template, elementName);\n    },\n\n    /**\n     * @param {!HTMLTemplateElement} template\n     * @param {string} elementName\n     * @param {string=} elementExtends\n     */\n    prepareTemplateStyles(template, elementName, elementExtends) {\n      window.ShadyCSS.prepareTemplate(template, elementName, elementExtends);\n    },\n\n    /**\n     * @param {!HTMLTemplateElement} template\n     * @param {string} elementName\n     */\n    prepareTemplateDom(template, elementName) {}, // eslint-disable-line no-unused-vars\n\n    /**\n     * @param {!HTMLElement} element\n     * @param {Object=} properties\n     */\n    styleSubtree(element, properties) {\n      applyShimInterface.flushCustomStyles();\n      applyShimInterface.styleSubtree(element, properties);\n    },\n\n    /**\n     * @param {!HTMLElement} element\n     */\n    styleElement(element) {\n      applyShimInterface.flushCustomStyles();\n      applyShimInterface.styleElement(element);\n    },\n\n    /**\n     * @param {Object=} properties\n     */\n    styleDocument(properties) {\n      applyShimInterface.flushCustomStyles();\n      applyShimInterface.styleDocument(properties);\n    },\n\n    /**\n     * @param {Element} element\n     * @param {string} property\n     * @return {string}\n     */\n    getComputedStyleValue(element, property) {\n      return getComputedStyleValue(element, property);\n    },\n\n    flushCustomStyles() {\n      applyShimInterface.flushCustomStyles();\n    },\n\n    nativeCss: nativeCssVariables,\n    nativeShadow: nativeShadow,\n    cssBuild: cssBuild,\n    disableRuntime: disableRuntime,\n  };\n\n  if (CustomStyleInterface) {\n    window.ShadyCSS.CustomStyleInterface = CustomStyleInterface;\n  }\n}\n\nwindow.ShadyCSS.ApplyShim = applyShim;\n"]}